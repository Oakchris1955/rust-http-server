<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Oak HTTP server tutorial</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting started</li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="minimal-example.html"><strong aria-hidden="true">3.</strong> Minimal example</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced usage</li><li class="chapter-item expanded "><a href="http-protocol.html"><strong aria-hidden="true">4.</strong> About the HTTP protocol</a></li><li class="chapter-item expanded "><a href="request-handlers.html"><strong aria-hidden="true">5.</strong> Request handlers</a></li><li class="chapter-item expanded "><a href="request-response-structs.html"><strong aria-hidden="true">6.</strong> The Request and Response structs</a></li><li class="chapter-item expanded "><a href="generic-data-structures.html"><strong aria-hidden="true">7.</strong> Other important data structures</a></li><li class="chapter-item expanded affix "><li class="part-title">Library modules</li><li class="chapter-item expanded "><a href="modules-introduction.html"><strong aria-hidden="true">8.</strong> What are they?</a></li><li class="chapter-item expanded "><a href="handlers-module.html"><strong aria-hidden="true">9.</strong> Handlers</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Oak HTTP server tutorial</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>NOTE:</strong> This project is still in early Beta. With that being said, lower your expectations.</p>
<p>The <strong>Oak HTTP server</strong> library, also called <strong>OakHTTP</strong>, is a personal project of mine aiming to create a HTTP server library in Rust whose usage is similar to that of the <code>express.js</code> JavaScript library.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>OakHTTP is free and open source. You can find the source code on <a href="https://github.com/Oakchris1955/rust-http-server">GitHub</a> and issues and feature requests can be posted on the <a href="https://github.com/Oakchris1955/rust-http-server/issues">GitHub issue tracker</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The OakHTTP library and it's documentation are released under the <a href="https://github.com/Oakchris1955/rust-http-server/blob/main/LICENSE">MIT License</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Before using the library, you should install it first.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Make sure that you have the followings installed:</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">The Rust programming language</a></li>
<li><a href="https://github.com/rust-lang/cargo">Cargo</a>, which should come along with Rust by default</li>
</ul>
<p>To check if you already have all the above installed, run the following commands:</p>
<ol>
<li><code>rustup --version</code> and <code>rustc --version</code> to check whether Rust is installed</li>
<li><code>cargo --version</code> for Cargo</li>
</ol>
<p>If all the above commands run successfully and return without an error, that means that they are successfully installed</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project setup</a></h2>
<p>Once you have installed both off them, you must create a new Cargo package. Do this by running <code>cargo new oak-http-tutorial</code>, which will create a new directory named <code>oak-http-tutorial</code>, containing a Cargo package and a <a href="https://git-scm.com/">Git</a> repository.</p>
<p>Now that you have created a new package, <code>cd</code> to it using <code>cd oak-http-tutorial</code>.</p>
<h2 id="add-oakhttp-as-a-project-dependency"><a class="header" href="#add-oakhttp-as-a-project-dependency">Add OakHTTP as a project dependency</a></h2>
<p>There are two (2) ways to add a package published at <a href="https://crates.io/">https://crates.io/</a> as a project dependency.</p>
<ol>
<li>Run <code>cargo add oak-http-server</code> while on the same directory as the project. After a few seconds, the latest version of the OakHTTP library should now be a dependency of your project</li>
<li>Open the <code>Cargo.toml</code> in the project's root and add a new line in the follwoing format under the <code>[dependencies]</code> section (create one if it doesn't exist) containing the string <code>oak-http-server = &quot;VERSION&quot;</code>, where <code>VERSION</code> is which version of the library to install (check all available versions at <a href="https://crates.io/crates/oak-http-server/versions">https://crates.io/crates/oak-http-server/versions</a>)</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="minimal-server-example"><a class="header" href="#minimal-server-example">Minimal server example</a></h1>
<p>Once you have successfully setup everything, it is time to create an example</p>
<h2 id="editing-mainrs"><a class="header" href="#editing-mainrs">Editing main.rs</a></h2>
<p>Let's begin by editing the <code>main.rs</code> file, which is from where our project's code is executed</p>
<p>Initially, <code>main.rs</code> should look like this</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Let's begin by including the library on the top of our <code>main.rs</code> file</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate oak_http_server;
</span>use oak_http_server::{Server, Status};
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let hostname = &quot;localhost&quot;;
</span><span class="boring">    let port: u16 = 2300;
</span><span class="boring">
</span><span class="boring">    let mut server = Server::new(hostname, port);
</span><span class="boring">
</span><span class="boring">    server.on(&quot;/hello&quot;, |_request, response| {
</span><span class="boring">        response.send(&quot;Hello, World!&quot;)
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    server.start(|| {
</span><span class="boring">        println!(&quot;HTTP server is now running...&quot;);
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<p>Next, create a new <code>Server</code> instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate oak_http_server;
</span><span class="boring">use oak_http_server::{Server, Status};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let hostname = &quot;localhost&quot;;
    let port: u16 = 2300;

    let mut server = Server::new(hostname, port);
<span class="boring">
</span><span class="boring">    server.on(&quot;/hello&quot;, |_request, response| {
</span><span class="boring">        response.send(&quot;Hello, World!&quot;)
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    server.start(|| {
</span><span class="boring">        println!(&quot;HTTP server is now running...&quot;);
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<p>Add a basic handler that always returns a static response:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate oak_http_server;
</span><span class="boring">use oak_http_server::{Server, Status};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let hostname = &quot;localhost&quot;;
</span><span class="boring">    let port: u16 = 2300;
</span><span class="boring">
</span><span class="boring">    let mut server = Server::new(hostname, port);
</span><span class="boring">
</span>    server.on(&quot;/hello&quot;, |_request, response| {
        response.send(&quot;Hello, World!&quot;)
    });
<span class="boring">
</span><span class="boring">    server.start(|| {
</span><span class="boring">        println!(&quot;HTTP server is now running...&quot;);
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<p>Lastly, start the HTTP server:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate oak_http_server;
</span><span class="boring">use oak_http_server::{Server, Status};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let hostname = &quot;localhost&quot;;
</span><span class="boring">    let port: u16 = 2300;
</span><span class="boring">
</span><span class="boring">    let mut server = Server::new(hostname, port);
</span><span class="boring">
</span><span class="boring">    server.on(&quot;/hello&quot;, |_request, response| {
</span><span class="boring">        response.send(&quot;Hello, World!&quot;)
</span><span class="boring">    });
</span><span class="boring">
</span>    server.start(|| {
        println!(&quot;HTTP server is now running...&quot;);
    });
<span class="boring">}
</span></code></pre></pre>
<p>Now, if you open your web browser and navigate to <code>localhost:2300/hello</code>, you should see a webpage displaying your message:
<img src="img/minimal-server-browser-view.png" alt="miimal-server-view" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="about-the-http-protocol"><a class="header" href="#about-the-http-protocol">About the HTTP protocol</a></h1>
<p>In order to be able to understand what this library does, you must first understand the basics of the <strong>HTTP protocol</strong></p>
<h2 id="so-what-exactly-is-http-anyways"><a class="header" href="#so-what-exactly-is-http-anyways">So, what exactly is HTTP anyways</a></h2>
<p>HTTP stands for <strong>HyperText Transfer Protocol</strong> and is one of the most popular ways of <strong>client-server communication</strong> in the Internet. In HTTP, the server is listening for requests from clients, handles them accordingly and then sends a response back to the client.</p>
<p>Let's take a look at how a typical <strong>HTTP exchange</strong> looks like:</p>
<ol>
<li>A connection is established between the client and the server on an underlying protocol, most commonly <strong>TCP</strong></li>
<li>The client begins sending data to the server in the form of a HTTP request. If it doesn't and stays idle, the server will most likely drop the connection after a timeout</li>
<li>Once the client is done sending data to the server, the server will then process this data and send a response back to the user</li>
<li>The connection may or may not be dropped then. This depends both on the client and the server. In case the connection isn't dropped, it could be used later on to exchange more data</li>
</ol>
<p>In any case, if any request or response is found malformed, the server or the client respectively have the right to drop the connection immediately.</p>
<h2 id="http-messages"><a class="header" href="#http-messages">HTTP messages</a></h2>
<p>It should be noted that both HTTP requests and responses are HTTP messages and both follow the same format, with some exceptions. Both of them have:</p>
<ul>
<li>The HTTP version of the message</li>
<li>Various headers</li>
<li>Body message (it isn't necessary for a HTTP message to have one, some of them have a body length of 0)</li>
</ul>
<p>Furthermore, a request has the following:</p>
<ul>
<li>A request method</li>
<li>A target path</li>
</ul>
<p>Lastly, a HTTP response has:</p>
<ul>
<li>A response status code</li>
<li>A response status text (dependent on the status code)</li>
</ul>
<h2 id="http-requests"><a class="header" href="#http-requests">HTTP requests</a></h2>
<p>A HTTP request is exactly what it says: a request towards the server to access some data. The most important fields are the method and the target.</p>
<h3 id="http-methods"><a class="header" href="#http-methods">HTTP Methods</a></h3>
<p>There are many HTTP request methods, the most common of which are:</p>
<ul>
<li><code>GET</code>: Requests a representation of the specified resource</li>
<li><code>HEAD</code>: Asks for a response identical to a GET request, but without the response body</li>
<li><code>POST</code>: Submits an entity to the specified resource, often causing a change in state or side effects on the server.</li>
<li><code>PUT</code>: Same as <code>PUT</code>, except that calling it once or several times successively has the same effect (that is no side effect), where successive identical POST may have additional effects</li>
<li><code>DELETE</code>: Deletes the specified resource.</li>
</ul>
<h3 id="http-target"><a class="header" href="#http-target">HTTP target</a></h3>
<p>The request target on the other hand is a string that represents the resource to access.</p>
<p>For example, calling <code>GET</code> at a resource could return that resource, calling <code>DELETE</code> could delete it. It is up to the server to decide how to implement each method. This library gives control over the user on how to do that</p>
<h2 id="http-responses"><a class="header" href="#http-responses">HTTP responses</a></h2>
<p>A HTTP response on the other hand is sent by the server in order to notify the client about the result of the request or send back some data. There is basically one field here, which is the response status field</p>
<h3 id="http-status-codes"><a class="header" href="#http-status-codes">HTTP status codes</a></h3>
<p>The HTTP status codes are 3-digit number that are divided into 5 categories:</p>
<ol>
<li>Informational responses (100 – 199)</li>
<li>Successful responses (200 – 299)</li>
<li>Redirection messages (300 – 399)</li>
<li>Client error responses (400 – 499)</li>
<li>Server error responses (500 – 599)</li>
</ol>
<p>The most commonly know status codes are:</p>
<ul>
<li><code>200 OK</code>: The request succeeded.</li>
<li><code>301 Moved Permanently</code>: The URL of the requested resource has been changed permanently. The new URL is given in the response. Most commonly used in redirects</li>
<li><code>308 Permanent Redirect</code>: Like <code>301</code>, but the user can't switch methods.</li>
<li><code>400 Bad Request</code>: The request is malformed and won't be processed</li>
<li><code>401 Unauthorized</code>: The client must authenticate itself to get the requested response and make itself known to the server.</li>
<li><code>402 Forbidden</code>: Like <code>401</code>, but the server knows who the client is, the client just isn't authorized <strong>enough</strong> to access the resource.</li>
<li><code>404 Not Found</code>: The server cannot find the requested resource. In an API, this can also mean that the endpoint is valid but the resource itself does not exist.</li>
<li><code>429 Too Many Requests</code>: The user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</li>
<li><code>500 Internal Server Error</code>: The server has encountered a situation it does not know how to handle. Usually indicates an in-server error.</li>
</ul>
<h3 id="http-headers"><a class="header" href="#http-headers">HTTP headers</a></h3>
<p>Headers provided information about the message itself, it's encoding, the body length, even the time it was made. For a detailed list of them, check this link: <a href="https://www.iana.org/assignments/message-headers/message-headers.xhtml">https://www.iana.org/assignments/message-headers/message-headers.xhtml</a></p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>For more info, check the <a href="https://developer.mozilla.org/en-US/">MDN Docs</a> and <a href="https://www.codetinkerer.com/2015/12/04/choosing-an-http-status-code.html">this webpage</a> by <a href="https://www.codetinkerer.com/about">Michael Kropat</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="request-handlers"><a class="header" href="#request-handlers">Request handlers</a></h1>
<p>So far we have learned what a HTTP server is capable of, but how exactly do we program one using this library? In this chapter, you will learn how to write custom request handlers and how to use some that the library already provides.</p>
<h2 id="the-handler-concept"><a class="header" href="#the-handler-concept">The handler concept</a></h2>
<p>The usage concept of this library is centered around simplicity: this library shouldn't be pretty complicated in terms of design, but it should also provide broad control to the end user over the HTTP connection.</p>
<p>In order to achieve this, the way the library is built gives full control to the user over a HTTP request and the corresponding response (in the case the request isn't malformed by the user, of course. In that case, the connection is dropped before the user gets the chance to handle the connection)</p>
<h2 id="what-is-a-handler-anyways"><a class="header" href="#what-is-a-handler-anyways">What is a handler anyways?</a></h2>
<p>As defined in <code>lib.rs</code>, the type <code>HandlerCallback</code> is a dynamically dispacted <code>Fn(Request, Response)</code>, where <code>Request</code> and <code>Response</code> and the request and response structs correspondingly. What this basically means is that any function whose has 2 arguments, the first one of which is a <code>Request</code> and the second one a <code>Response</code> is a valid <code>HandlerCallback</code></p>
<p>For example, the following function falls under the aforementioned criteria:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate oak_http_server;
</span><span class="boring">use oak_http_server::{Request, Response, Server};
</span><span class="boring">
</span>fn example_handler_func(_request: Request, response: Response) {
    // This handler responds to the HTTP request with a predefined string
    response.send(&quot;I am a concrete function handler!!!&quot;);
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let example_handler_closure = |_request: Request, response: Response| {
</span><span class="boring">        // This handler responds to the HTTP request with a predefined string
</span><span class="boring">        response.send(&quot;And I am a closure!!!&quot;);
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let hostname = &quot;localhost&quot;;
</span><span class="boring">    let port: u16 = 2300;
</span><span class="boring">
</span><span class="boring">    // Create a Server instance
</span><span class="boring">    let mut server = Server::new(hostname, port);
</span><span class="boring">
</span><span class="boring">    // Append generic function handler
</span><span class="boring">    server.on(&quot;/function&quot;, example_handler_func);
</span><span class="boring">
</span><span class="boring">    // Append closure handler that responds only to `GET` requests
</span><span class="boring">    server.on_get(&quot;/closure&quot;, example_handler_closure);
</span><span class="boring">
</span><span class="boring">    // Start the HTTP server
</span><span class="boring">    server.start(|| {
</span><span class="boring">        println!(&quot;HTTP server is now running...&quot;);
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<p>Since our handler is a <code>Fn</code> trait and not a concrete <code>fn</code> type, we call also pass closures as handlers. The following closure is also a valid handler</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate oak_http_server;
</span><span class="boring">use oak_http_server::{Request, Response, Server};
</span><span class="boring">
</span><span class="boring">fn example_handler_func(_request: Request, response: Response) {
</span><span class="boring">    // This handler responds to the HTTP request with a predefined string
</span><span class="boring">    response.send(&quot;I am a concrete function handler!!!&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let example_handler_closure = |_request: Request, response: Response| {
        // This handler responds to the HTTP request with a predefined string
        response.send(&quot;And I am a closure!!!&quot;);
    };
<span class="boring">
</span><span class="boring">    let hostname = &quot;localhost&quot;;
</span><span class="boring">    let port: u16 = 2300;
</span><span class="boring">
</span><span class="boring">    // Create a Server instance
</span><span class="boring">    let mut server = Server::new(hostname, port);
</span><span class="boring">
</span><span class="boring">    // Append generic function handler
</span><span class="boring">    server.on(&quot;/function&quot;, example_handler_func);
</span><span class="boring">
</span><span class="boring">    // Append closure handler that responds only to `GET` requests
</span><span class="boring">    server.on_get(&quot;/closure&quot;, example_handler_closure);
</span><span class="boring">
</span><span class="boring">    // Start the HTTP server
</span><span class="boring">    server.start(|| {
</span><span class="boring">        println!(&quot;HTTP server is now running...&quot;);
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="appending-handlers"><a class="header" href="#appending-handlers">Appending handlers</a></h2>
<p>So far we've seen how to create a handler, but we also must let the <code>Server</code> struct know of them. Before checking how this is done, let's check at the different types of request handlers, as defined in <code>lib.rs</code>:</p>
<ol>
<li><code>Any</code>: This handler will be executed on any requested at the specified target</li>
<li><code>Specific</code>: This handler will be executed only on requests made using a specific HTTP method (<code>GET</code>, <code>POST</code>, etc) at the specified target</li>
<li><code>Directory</code>: This handler type requires a seperate chapter on its own and won't be covered here. All you need to know is that it is called not in just one target, but multiple that fall under the same path (a <code>Directory</code> handler attached at <code>/foo</code> will be called on <code>/foo/etc</code>, <code>/foo/some</code> and so on)</li>
</ol>
<p>The <code>Server</code> struct provides us with some methods in order to attach handlers. These are the following:</p>
<ol>
<li><code>Server::on()</code> to attach generic <code>Any</code> handlers</li>
<li><code>Server::on_METHOD()</code> to attach handler for a specific <code>METHOD</code> (for example, <code>on_get</code> attaches a <code>Specific</code> <code>GET</code> handler)</li>
<li><code>Server::on_directory()</code> to attach a <code>Directory</code> handler</li>
</ol>
<p>All the above function have the same function signature: that means that all of them take a <code>&amp;str</code> or <code>String</code> as the target argument and a <code>HandlerCallback</code> as the second argument</p>
<p>Let's attach those handlers to our server now:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate oak_http_server;
</span>use oak_http_server::{Request, Response, Server};

fn example_handler_func(_request: Request, response: Response) {
    // This handler responds to the HTTP request with a predefined string
    response.send(&quot;I am a concrete function handler!!!&quot;);
}

fn main() {
    let example_handler_closure = |_request: Request, response: Response| {
        // This handler responds to the HTTP request with a predefined string
        response.send(&quot;And I am a closure!!!&quot;);
    };

    let hostname = &quot;localhost&quot;;
    let port: u16 = 2300;

    // Create a Server instance
    let mut server = Server::new(hostname, port);

    // Append generic function handler
    server.on(&quot;/function&quot;, example_handler_func);

    // Append closure handler that responds only to `GET` requests
    server.on_get(&quot;/closure&quot;, example_handler_closure);

    // Start the HTTP server
    server.start(|| {
        println!(&quot;HTTP server is now running...&quot;);
    });
}
</code></pre></pre>
<p>Similarly, you can create your own handlers. With this library, the sky's the limit to what you can do.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-request-and-response-structs"><a class="header" href="#the-request-and-response-structs">The Request and Response structs</a></h1>
<p>In the past chapter, we covered basically everything about request handlers and how to utilize them, but we still haven't learned what kind of data we can read from the <code>Request</code> and <code>Response</code> structs passed to each handler. Let's find out</p>
<h2 id="some-general-info"><a class="header" href="#some-general-info">Some general info</a></h2>
<p>Before we move on, we should probably clarify a difference between the two structs:</p>
<ul>
<li>
<p>The <code>Request</code> struct is basically a read-only struct: that means that the user should only care about the struct's fields and that not many methods are available to modify the struct.</p>
</li>
<li>
<p>On the other hand, the <code>Response</code> struct is a write-only struct, which means that the user mainly calls methods from this struct and that most of the operations. can be done through methods</p>
</li>
</ul>
<p>Furthermore, both structs contain the following fields:</p>
<ul>
<li><code>version</code>: The HTTP version of the <code>Request</code>/<code>Response</code>. A simple struct with two fields: <code>major</code> and <code>minor</code>.</li>
<li><code>headers</code>: A <code>HashMap</code> of <code>String</code> to <code>String</code> that contains the <code>Request</code>/<code>Response</code> headers. For each pair, the key is the header name and the value the header value</li>
</ul>
<h2 id="the-request-struct"><a class="header" href="#the-request-struct">The Request struct</a></h2>
<p>The <code>Request</code> struct contains info about the request made by the user.</p>
<p>It contains the following fields:</p>
<ul>
<li><code>method</code>: A <code>Method</code> enum that represents the HTTP method of this request (pretty useful if you have a generic handler and the logic of your handler depends on the HTTP method of the request)</li>
<li><code>target</code>: A <code>Target</code> struct representing the target URL of the <code>Request</code>. More info about this on a seperate chapter</li>
</ul>
<h2 id="the-response-struct"><a class="header" href="#the-response-struct">The Response struct</a></h2>
<p>The <code>Response</code> struct contains info about the response to send to the user, along with some methods to actually send the response.</p>
<p>It contains the following field:</p>
<ul>
<li><code>status</code>: A <code>Status</code> enum that represents the HTTP response status</li>
</ul>
<p>This struct also contains some methods:</p>
<ul>
<li><code>status</code>: Changes the <code>Response</code>'s <code>status</code> field. Take a single parameter, the <code>Status</code> to which to set the <code>status</code> field of the <code>Response</code></li>
<li><code>send</code>: Sends the <code>Response</code> to the user, while consuming the <code>Response</code> struct. Takes a single argument, which is the body content for the <code>Response</code></li>
<li><code>end</code>: Same as <code>send</code>, but send a body content with zero (0) length</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="various-important-data-structures"><a class="header" href="#various-important-data-structures">Various important data structures</a></h1>
<p>We have talked quite a lot about the <code>Response</code> and the <code>Request</code> structs, but of course this crates contains more than just these two structs. Let's take a closer look at what else is provided. It should be noted however that not all of the items here might be useful for the average library user; thischapter is meant to act more as a part of the documentation rather than a part of this tutorial book</p>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<h3 id="target"><a class="header" href="#target"><code>Target</code></a></h3>
<p>One of the most useful structs on this crate. Represents a HTTP URL/Target and also contains any HTTP queries passed in the URL.</p>
<ul>
<li>
<p>Fields</p>
<ul>
<li><code>target_path</code>: A <code>String</code> contains the path of the current handler (the string the user passes into the handler attach functions of the <code>Server</code> struct. For example, if we attach a handler into a <code>X</code> path, that would be the <code>X</code> string). Usually empty, except when the handler variant is set to <code>Directory</code></li>
<li><code>relative_path</code>: A <code>String</code> containing the rest of the URL, excluding <code>target_path</code></li>
<li><code>queries</code>: A <code>HashMap</code> of <code>String</code> to <code>String</code>. Each key-value pair represents the name and the value of a HTTP query</li>
</ul>
</li>
<li>
<p>Methods</p>
<ul>
<li><code>full_url()</code>: Appends <code>relative_path</code> into <code>target_path</code>, returns the result as a <code>String</code></li>
</ul>
</li>
<li>
<p>Note</p>
<ul>
<li>In order to get the original HTTP URL, use the <code>to_string()</code> method (implemented with the <code>Display</code> trait)</li>
</ul>
</li>
</ul>
<h3 id="version"><a class="header" href="#version"><code>Version</code></a></h3>
<p>Represents the HTTP version of a <code>Request</code> or <code>Response</code>.</p>
<ul>
<li>
<p>Fields</p>
<ul>
<li><code>major</code>: A <code>usize</code> representing the major revision number of the HTTP version. The major revision number signifies significant updates and changes to the HTTP protocol.</li>
<li><code>minor</code>: A <code>usize</code> representing the minor revision number of the HTTP version. The minor revision number indicates smaller updates and improvements made to the HTTP protocol without introducing major changes.</li>
</ul>
</li>
</ul>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<h3 id="method"><a class="header" href="#method"><code>Method</code></a></h3>
<p>The HTTP method of the HTTP <code>Request</code></p>
<ul>
<li>
<p>Variants</p>
<ul>
<li>
<p><code>GET</code>: The <code>GET</code> method requests a representation of the specified resource. Requests using <code>GET</code> should only retrieve data.</p>
</li>
<li>
<p><code>HEAD</code>: The <code>HEAD</code> method asks for a response identical to a the response to a <code>GET</code> request, but without the response body.</p>
</li>
<li>
<p><code>POST</code>: The <code>POST</code> method submits an entity to the specified resource, often causing a change in state or side effects on the server.</p>
</li>
<li>
<p><code>PUT</code>: The <code>PUT</code> method replaces all current representations of the target resource with the request payload.</p>
</li>
<li>
<p><code>DELETE</code>: The <code>DELETE</code> method deletes the specified resource.</p>
</li>
</ul>
</li>
<li>
<p>Note</p>
<ul>
<li>This enum is marked as non-exhaustive, which means that it could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm (<code>_ =&gt; { ... }</code>) must be added to account for any future variants.</li>
</ul>
</li>
</ul>
<h3 id="handlermethod"><a class="header" href="#handlermethod"><code>HandlerMethod</code></a></h3>
<p>Extends the <code>Method</code> enum. Indicates when a handler should be called</p>
<ul>
<li>
<p>Variants</p>
<ul>
<li><code>Directory</code>: Represents a directory handler. It is the last handler type in terms of execution priority (that means that it will be called only when there is no other handler for a <code>Request</code>). Allows for the existance of more complicated handlers, such as file and directory handlers (as the name suggests). For example, if a <code>Directory</code> handler is attached to the <code>X</code> path, any <code>Request</code> whose <code>Target</code> URL begins with <code>X</code> will be executed by the handler</li>
<li><code>Specific(Method)</code>: The handler will called when a <code>Request</code> with a <code>Specific</code> HTTP <code>Method</code> is made at the target path (<code>GET</code>, <code>POST</code>, etc.)</li>
<li><code>Any</code>: The handler will be called on any <code>Request</code> under the specified path</li>
</ul>
</li>
</ul>
<h3 id="status"><a class="header" href="#status"><code>Status</code></a></h3>
<p>The HTTP status of a <code>Response</code></p>
<ul>
<li>
<p>Variants</p>
<ul>
<li><code>OK</code>: 200 OK</li>
<li><code>Created</code>: 201 Created</li>
<li><code>Accepted</code>: 202 Accepted</li>
<li><code>NoContent</code>: 203 No Content</li>
<li><code>BadRequest</code>: 400 Bad Request</li>
<li><code>NotFound</code>: 404 Not Found</li>
<li><code>InternalError</code>: 500 Internal Server Error</li>
<li><code>NotImplemented</code>: 501 Not Implemented</li>
</ul>
</li>
<li>
<p>Note</p>
<ul>
<li>This enum is marked as non-exhaustive, which means that it could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm (<code>_ =&gt; { ... }</code>) must be added to account for any future variants.</li>
</ul>
</li>
</ul>
<h2 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h2>
<h3 id="handler"><a class="header" href="#handler"><code>Handler</code></a></h3>
<p>Represents a <code>Request</code> handler</p>
<h3 id="handlercallback"><a class="header" href="#handlercallback"><code>HandlerCallback</code></a></h3>
<p>The type of the function that processes a HTTP <code>Request</code> passed into a <code>Handler</code></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="library-modules"><a class="header" href="#library-modules">Library modules</a></h1>
<p>All the items of the library we have shown so far are located in the root of the crate. This means that if we wanna import the <code>Server</code> struct, we would do something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate oak_http_server;
</span>use oak_http_server::Server;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    /* Your code goes here... */
</span><span class="boring">}
</span></code></pre></pre>
<p>Modules are different: they play a crucial role in organizing and structuring the codebase, while they also serve as a way to group related functions. They help developers keep their code organized, make it easier to reuse code, and allow them to focus on specific parts of their project. For users, modules in a Rust crate make it easy to find and use the features they need while keeping everything organized and straightforward.</p>
<p>In general, items of this crate necessary for the crate to function, as well as widely used items, will be located in the root of the crate, whereas more specific items items will be located within modules.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="handlers-module"><a class="header" href="#handlers-module">Handlers module</a></h1>
<p>We have already seen how a user can write it's own request handlers, but this doesn't mean that the crate doesn't come with some prewritten handlers.</p>
<h2 id="read_same_dir"><a class="header" href="#read_same_dir"><code>read_same_dir</code></a></h2>
<p>Let's say that you want the server to serve some statis files, like images, HTML files or god knows what. Well, that's what this function essentially does: reads from the same directory as the path of the URL and sends them to the client.</p>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>Simply pass the <code>read_same_dir</code> into your desired handler append function</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate oak_http_server;
</span>use oak_http_server::{handlers::read_same_dir, Server};

fn main() {
    let hostname = &quot;localhost&quot;;
    let port: u16 = 2300;

    let mut server = Server::new(hostname, port);

    // The handler will serve static files from the local '/www' path
    server.on_directory(&quot;/www&quot;, read_same_dir);

    server.start(|| {
        println!(&quot;HTTP server is now running...&quot;);
    });
}
</code></pre></pre>
<p>In the above example, if the user requests a target at <code>/www/example.txt</code>, the server will send back the file located at <code>./www/example.txt</code> if it exists, otherwise it will respond with a <code>404 Not Found</code> error or <code>500 Internal Server Error</code> if the file exists and can't be opened</p>
<h2 id="read_diff_dir"><a class="header" href="#read_diff_dir"><code>read_diff_dir()</code></a></h2>
<p>Same as above, but reads files from a directory different than the target directory.</p>
<h3 id="usage-1"><a class="header" href="#usage-1">Usage</a></h3>
<p>Pass the <code>read_diff_dir(READ_PATH)</code> into your desired handler append function, and substitute <code>READ_PATH</code> with the path from which you want the files to be read</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate oak_http_server;
</span>use oak_http_server::{handlers::read_diff_dir, Server};

fn main() {
    let hostname = &quot;localhost&quot;;
    let port: u16 = 2300;

    let mut server = Server::new(hostname, port);

    // The handler will serve static files for the '/www' path from the local '/diff' path
    server.on_directory(&quot;/www&quot;, read_diff_dir(&quot;/diff&quot;));

    server.start(|| {
        println!(&quot;HTTP server is now running...&quot;);
    });
}
</code></pre></pre>
<p>In the above example, if the user requests a target at <code>/www/example.txt</code>, the server will send back the file located at <code>./diff/example.txt</code> if it exists, otherwise it will respond with a <code>404 Not Found</code> error or <code>500 Internal Server Error</code> if the file exists and can't be opened</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
